월간 개발 보고 (7월)
=====

개요
-----
본 보고는 사업계획서의 <월별 주요 일정> 항목에서 ___EPL Interpreter 구현___ 과 ___Translator 구현 (Python)___ 에 해당하는 내용 중 7월(7월 15일 ~ 8월 16일)의 개발 기록과 성과를 정리합니다. 

위의 항목에 해당하는 모든 구현은 본 [Github 프로젝트(Mocca)](http://github.com/ngEPL/Mocca)에서 관리되며, 개발 기록이 상시 공개되어 있습니다. 본 과제의 다른 개발 기록은 [Github Organization](http://github.com/ngEPL)에서 확인하실 수 있습니다.

본 보고는 홍승환(총괄책임자, EPL 코어 담당)에 의해 쓰여졌습니다.

‘Mocca’
-----
저희는 기존의 사업 계획에 현재 존재하는 다른 교육용 프로그래밍 도구(이하 ‘EPL’)들의 단점들을 보완하겠다고 계획하였고, 그것을 구현하기 위해서는 블록 구조를 프로그램 내부에서 다룰 수 있게 해주는, __중간 언어__ 가 필요했습니다.

이 중간 언어는, 이용자들이 블럭을 조립하여 코딩을 하면, 그것을 컴퓨터가 이해할 수 있는 형태로 변환하기 위하여 우선적으로 해석되는 언어로써 기능합니다. 그렇기 때문에, 모든 블록들이 이 언어로 매끄럽게 바뀌어야 하며, 이 언어가 다른 프로그래밍 언어로 다시 매끄럽게 바뀌게 하는 기능이 필수적입니다.

그래서 저희는 기존에 나와있는 다른 언어로 중간 언어를 대체하면 EPL의 효율성이 떨어질 것으로 판단, __직접 언어를 제작하기로 결정__ 하였습니다.

그 언어의 이름을 Mocca라고 지었으며, 비공식적으로 프로토타이핑을 진행하고 2016년 7월 24일을 기점으로 Github에서 코드를 관리하기 시작했습니다.

본 프로젝트는 오픈소스 프로젝트(Open Source Project)로써, 저희가 개발한 내용이 대중에게 그대로 공개되어 투명하게 관리됩니다. 또한, MIT License를 채택하여 출처와 저작권만을 명시하면 수정 / 배포 / 상업적 이용이 가능하게 하여 기술을 완벽히 공개했습니다.

개발 상황
-----

#### 개요
현재(2016년 8월 15일 기준) Mocca는 19개의 Commit을 기록하였고, 다양한 기능이 추가되었습니다. 일반적으로 컴파일러를 개발하는 수순을 그대로 따랐으며, 현재 전체 개발의 __30%__ 정도가 진척되었습니다. 현재 언어를 분리하여 식별자 단위로 만들고, 파스 트리(Parse Tree; 언어의 구조를 나무 모양의 구조로 나타낸 것)를 만들어 출력하는 것까지 개발되었습니다.

#### [Example : middle_lang.mocca](http://github.com/ngEPL/Mocca/Example/middle_lang.mocca)
이 파일은 이 언어의 구성을 보여줍니다. 이용자가 저희의 EPL을 이용하여 코딩을 할 때, `.mocca` 확장자로 저장할 수 있고, 이 파일은 PC와 모바일에 관계없이 어느 환경에서나 인식되어야 합니다. 그래서 한 파일에 _문서의 정보_ 와 _블록 코딩 구조_ 가 모두 담길 수 있는 `XML` 구조로 설계하였습니다.

코드는 `blockgroup` 키워드를 기준으로 전체적으로 3개의 묶음으로 이루어져 있으며, 순서대로 _변수 설정_, _명령문_, _논리 구조(분기, 반복)_ 으로 분리되어 있습니다. 

#### [Example : grammar.bnf](http://github.com/ngEPL/Mocca/Example/grammar.bnf)
이 파일은 이 언어의 논리적 구조를 보여줍니다. 완전무결한 언어를 제작하기 위해서는 수학적이고 논리적인 언어 구조가 미리 정의되어 있어야 합니다. 이 파일이 그 정의를 담고 있으며, 제작되는 컴파일러는 이 파일에 나와있는 수학적 구조대로 언어를 해석하게 됩니다.

#### [Mocca : Compiler.cs](http://github.com/ngEPL/Mocca/Mocca/Compiler.cs)
이 파일은 본격적인 언어의 구현이 시작되는 곳입니다. 언어의 내부 구조 명시와 해석 과정을 모두 하나의 파일에 관리하면 코드가 복잡해지고 유지보수가 어려워집니다. 그에 따라서 여러 파일에 구현을 분리해두었는데, 이 파일은 그 각각의 파일을 한 번에 관리할 수 있게 해줍니다. 이 프로젝트를 사용하는 프로그래머는 이 파일 하나를 통해서 언어를 해석하고, 결과를 자유자재로 다룰 수 있게 됩니다.

#### [Mocca : DataType.cs](http://github.com/ngEPL/Mocca/Mocca/DataType.cs)
이 파일에는 본 언어의 구조와 그 특성을 프로그램 상에서 논리적으로 정의하였습니다. 컴파일러 전역에서 이 파일에 접근하여 언어의 구조를 확인하고, 그 구조대로 언어를 재구성해서 다음 단계로 넘겨주게 됩니다. 결과적으로 EPL의 실제 보이는 부분을 개발하는 프로그래머는 여기에 정의된 논리 구조로 깔끔하게 재구성된 언어 구조를 받을 수 있게 됩니다.

#### [Mocca : ParseTree.cs](http://github.com/ngEPL/Mocca/Mocca/ParseTree.cs)
이 파일은 컴파일러가 언어를 해석할 때 그 구조의 중추가 되는 Parse Tree를 만드는 역할을 합니다. 언어를 구조적으로 정리해서 뻗어내려가는 나무 모양으로 정리하여, 구조적으로 탄탄하게 만들어서 의미를 분석하는 것에 모호함이 없게 해줍니다.

이 파일에는 Parse Tree를 만드는 기능 뿐만 아니라 언어를 해석하는 도중 문법적으로 오류가 있을 경우 어떤 오류인지 정리해서 시스템에 알려주는 역할을 하는 부분도 포함되어 있습니다. 이 구현은 에러가 났을 때 프로그램이 오작동하지 않고 적절하게 대응할 수 있는 능력을 부여하기 위하여 필수적입니다.

이 파일에는 분석된 Parse Tree를 위에 기술한 `DataType.cs`의 논리 구조에 의거하여 정리하는 부분이 포함되어 있는데, 그 기능을 현재 개발 중에 있습니다.

#### [Mocca : Parser.cs](http://github.com/ngEPL/Mocca/Mocca/Parser.cs)
이 파일은 컴파일러가 언어를 문법적으로 분석하여 그 구조가 무엇을 의미하는지 검사하는 부분입니다. 위에 기술한 Parse Tree를 만들기 위해서는 언어를 구조적으로 분석하여 적절한 단위로 분리해야 하는데, 이 파일에 있는 구현이 구조의 의미를 분석해 Parse Tree에 가지를 매달아주는 역할을 합니다. 모든 가지를 매달고 분석이 끝나면, 완성된 Parse Tree를 프로그래머에게 돌려줍니다.

#### [Mocca : Scanner.cs](http://github.com/ngEPL/Mocca/Mocca/Scanner.cs)
이 파일은 컴파일러가 언어를 분석하는 과정에서, 단위별로 뜯은 언어 구조들을 하나하나 스캔하면서 그 구조가 무엇을 의미하는지를 검사하는 역할을 합니다. 언어 전체를 한 단위씩 검사하여 이 단위가 어떠한 자료 형태를 가지는지를 검사합니다. 그 검사는 `Parser.cs`에서 요청되며, `Parser.cs`로 결과가 반환되어 문법 분석에 기여합니다.

개발 단계 정리와 계획
------
저희가 만드는 언어의 컴파일러는 다음과 같은 과정으로 동작합니다:
```
소스 코드가 컴파일러로 삽입
1. Lexical Analyzer(Scanner) : 구문 분석기
2. Syntax Analyzer(Parser)   : 문법 분석기
3. Semantic Analyzer(Parser) : 의미 분석기
4. Target Code Generator     : 최종 코드 생성기
```
여기에서 현재 구문 분석기와 문법 분석기가 개발되었으며, 다음 순서는 의미 분석기의 개발입니다. 다음 달에는 의미 분석기를 개발하여 언어가 의미적으로 무엇을 뜻하는지를 컴퓨터가 인식하게 하는 작업을 수행합니다. 끝.

라이센스 명시
------
본 프로젝트는 MIT License 하에 관리됩니다. 이 보고서를 포함한 모든 개발 과정은 해당 라이센스에 의해 모든 사람에게 공개됩니다.
